# generated by datamodel-codegen:
#   filename:  psu_api.yml
#   timestamp: 2024-12-12T19:58:59+00:00
#   source: https://github.com/nasa/uam-apis/blob/x4/openapi/psu/psu_api.yml

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import List, Optional
from uuid import UUID

from pydantic import BaseModel, Field, PositiveFloat, confloat, conint, constr


class UUIDv4Format(BaseModel):
    __root__: UUID = Field(
        ...,
        description='String whose format matches a version-4 UUID according to RFC 4122.',
        example='03e5572a-f733-49af-bc14-8a18bd53ee39',
    )


class EntityID(BaseModel):
    __root__: UUIDv4Format = Field(
        ...,
        description='Identifier for an Entity communicated through the DSS.  Formatted as\na UUIDv4.',
        example='2f8343be-6482-4d1b-a474-16847e01af1e',
    )


class EntityOVN(BaseModel):
    __root__: constr(min_length=16, max_length=128) = Field(
        ...,
        description='A token associated with a particular UAM Entity+version created\nby the DSS upon creation or modification of an Entity reference and provided\nto the client creating or modifying the Entity reference.  The EntityOVN\nis stored privately by the DSS and then compared against entries in a Key\nprovided to mutate the airspace.  The EntityOVN is also provided by\nthe client whenever that client transmits the full information of the Entity\n(either via GET, or via a subscription notification).',
        example='9d158f59-80b7-4c11-9c0c-8a2b4d936b2d',
        title='EntityOVN',
    )


class SubscriptionID(BaseModel):
    __root__: UUIDv4Format = Field(
        ...,
        description='Identifier for a subscription communicated through the DSS.  Formatted\nas a UUIDv4.',
        example='78ea3fe8-71c2-4f5c-9b44-9c02f5563c6f',
    )


class Key(BaseModel):
    __root__: List[EntityOVN] = Field(
        ...,
        description='Proof that a client has obtained the latest airspace content, used to ensure that write\noperations to the DSS occur only when the latest content is known (i.e. has been read). The\nclient is required to pass a current Key constructed from information obtained with\nprevious read operations and subsequent requests for full information, and optionally,\nsubscription updates for deconflicted write operations to the DSS.  The contents of this\ndata structure are generated by the client.\n',
    )


class Format(Enum):
    RFC3339 = 'RFC3339'


class Time(BaseModel):
    value: datetime = Field(
        ...,
        description="RFC3339-formatted time/date string.  The time zone must be 'Z'.",
        example='1985-04-12T23:20:50.52Z',
    )
    format: Format


class Units(Enum):
    M = 'M'


class Radius(BaseModel):
    value: PositiveFloat = Field(
        ...,
        description='Distance from the centerpoint of a circular area, along the WGS84 ellipsoid.',
        example=300.183,
    )
    units: Units = Field(
        ...,
        description='FIXM-compatible units.  Only meters ("M") are acceptable for UAM.',
    )


class Reference(Enum):
    W84 = 'W84'


class Altitude(BaseModel):
    value: confloat(ge=-8000.0, le=100000.0) = Field(
        ...,
        description='The numeric value of the altitude. Note that min and max values are\nadded as a sanity check. As use cases evolve and more options are\nmade available in terms of units of measure or reference systems,\nthese bounds may be re-evaluated.',
    )
    reference: Reference = Field(
        ...,
        description="A code indicating the reference for a vertical distance. See AIXM 5.1\nand FIXM 4.2.0. Currently, UAM only allows WGS84 with no immediate\nplans to allow other options. FIXM and AIXM allow for 'SFC' which is\nequivalent to AGL.",
    )
    units: Units = Field(
        ...,
        description='The reference quantities used to express the value of altitude. See\nFIXM 4.2. Currently, UAM only allows meters with no immediate plans\nto allow other options.',
    )


class Latitude(BaseModel):
    __root__: confloat(ge=-90.0, le=90.0) = Field(
        ...,
        description='Degrees of latitude north of the equator, with reference to the WGS84 ellipsoid.',
        example=34.123,
    )


class Longitude(BaseModel):
    __root__: confloat(ge=-180.0, le=180.0) = Field(
        ...,
        description='Degrees of longitude east of the Prime Meridian, with reference to the WGS84 ellipsoid.',
        example=-118.456,
    )


class LatLngPoint(BaseModel):
    lng: Longitude
    lat: Latitude


class Circle(BaseModel):
    center: LatLngPoint
    radius: Radius


class ErrorResponse(BaseModel):
    message: Optional[str] = Field(
        None,
        description='Human-readable message indicating what error occurred and/or why.',
        example='The error occurred because [...]',
    )


class SubscriptionNotificationIndex(BaseModel):
    __root__: conint(ge=0) = Field(
        ...,
        description='Tracks the notifications sent for a subscription so the subscriber can detect missed notifications more easily.',
    )


class UssBaseURL(BaseModel):
    __root__: str = Field(
        ...,
        description="The base URL of a PSU implementation of part or all of the PSU API. Per the PSU API, the full URL\nof a particular resource can be constructed by appending, e.g., `/psu/v1/{resource}/{id}` to this base URL.\nAccordingly, this URL may not have a trailing '/' character.",
        example='https://uam_psu.com/uam',
    )


class OperationalIntentState(Enum):
    Accepted = 'Accepted'
    Activated = 'Activated'
    Nonconforming = 'Nonconforming'
    Contingent = 'Contingent'


class OperationalIntentUssBaseURL(BaseModel):
    __root__: UssBaseURL = Field(
        ...,
        description='The base URL of a PSU implementation that implements the parts of the PSU API necessary for\nproviding the details of this operational intent, and telemetry during non-conformance or contingency,\nif applicable.',
    )


class ConstraintUssBaseURL(BaseModel):
    __root__: UssBaseURL = Field(
        ...,
        description='The base URL of a PSU implementation that implements the parts of the PSU API necessary for\nproviding the details of this constraint.',
    )


class PositionAccuracyVertical(Enum):
    VAUnknown = 'VAUnknown'
    VA150mPlus = 'VA150mPlus'
    VA150m = 'VA150m'
    VA45m = 'VA45m'
    VA25m = 'VA25m'
    VA10m = 'VA10m'
    VA3m = 'VA3m'
    VA1m = 'VA1m'


class PositionAccuracyHorizontal(Enum):
    HAUnknown = 'HAUnknown'
    HA10NMPlus = 'HA10NMPlus'
    HA10NM = 'HA10NM'
    HA4NM = 'HA4NM'
    HA2NM = 'HA2NM'
    HA1NM = 'HA1NM'
    HA05NM = 'HA05NM'
    HA03NM = 'HA03NM'
    HA01NM = 'HA01NM'
    HA005NM = 'HA005NM'
    HA30m = 'HA30m'
    HA10m = 'HA10m'
    HA3m = 'HA3m'
    HA1m = 'HA1m'


class PropertyType(Enum):
    TOP_OF_CLIMB = 'TOP_OF_CLIMB'
    TOP_OF_DESCENT = 'TOP_OF_DESCENT'
    TCP_VERTICAL = 'TCP_VERTICAL'
    TCP_SPEED = 'TCP_SPEED'
    TCP_LATERAL = 'TCP_LATERAL'
    WHEELS_OFF = 'WHEELS_OFF'
    WHEELS_ON = 'WHEELS_ON'
    AIRPORT_REFERENCE_LOCATION = 'AIRPORT_REFERENCE_LOCATION'
    WAYPOINT = 'WAYPOINT'
    ENTRY_CORRIDOR = 'ENTRY_CORRIDOR'
    EXIT_CORRIDOR = 'EXIT_CORRIDOR'
    CROSSING_TRACK = 'CROSSING_TRACK'
    MERGE_TRACK = 'MERGE_TRACK'


class TrajectoryProperty(BaseModel):
    property_type: PropertyType = Field(
        ...,
        description='Provides the type of trajectory point property. Enum list is based on the FIXM definition\nof TrajectoryPointPropertyType.\n',
    )


class Position(BaseModel):
    longitude: Longitude
    latitude: Latitude
    accuracy_h: Optional[PositionAccuracyHorizontal] = None
    accuracy_v: Optional[PositionAccuracyVertical] = None
    extrapolated: Optional[bool] = Field(
        False,
        description='True if this position was generated primarily by computation\nrather than primarily from a direct instrument measurement.',
    )
    altitude: Altitude


class UnitsSpeed(Enum):
    MetersPerSecond = 'MetersPerSecond'
    Knots = 'Knots'


class SpeedType(Enum):
    GROUND = 'GROUND'
    AIR = 'AIR'


class Velocity(BaseModel):
    speed: float = Field(..., description='Speed numerical value.', example=200.1)
    units_speed: UnitsSpeed
    track: Optional[float] = Field(
        0,
        description='Direction of flight expressed as a "True North-based" ground track angle.\nThis value is provided in degrees East of North with a minimum resolution of 1 degree.\nA value of 360 indicates invalid, no value, or unknown.',
        example=120,
    )
    speed_type: Optional[SpeedType] = Field(
        'GROUND', description='Air speed or ground speed'
    )


class UssAvailabilityState(Enum):
    Unknown = 'Unknown'
    Normal = 'Normal'
    Down = 'Down'


class RecorderRole(Enum):
    Client = 'Client'
    Server = 'Server'


class ExchangeRecord(BaseModel):
    url: str = Field(..., description='Full URL of request.')
    method: str = Field(
        ..., description='HTTP verb used by requestor (e.g., "PUT," "GET," etc.).'
    )
    headers: Optional[List[str]] = Field(
        [],
        description="Set of headers associated with request or response. Requires 'Authorization:' field (at a minimum)",
    )
    recorder_role: RecorderRole = Field(
        ...,
        description="A coded value that indicates the role of the logging PSU: 'Client' (initiating a request to a remote PSU) or 'Server' (handling a request from a remote PSU)",
    )
    request_time: Time = Field(
        ..., description='The time at which the request was sent/received.'
    )
    request_body: Optional[str] = Field(
        '', description='Base64-encoded body content sent/received as a request.'
    )
    response_time: Optional[Time] = Field(
        None, description='The time at which the response was sent/received.'
    )
    response_body: Optional[str] = Field(
        '',
        description='Base64-encoded body content sent/received in response to request.',
    )
    response_code: Optional[int] = Field(
        0, description='HTTP response code sent/received in response to request.'
    )
    problem: Optional[str] = Field(
        None,
        description='Human-readable description of the problem with the exchange, if any.',
    )


class ErrorReport(BaseModel):
    report_id: Optional[constr(max_length=128)] = Field(
        None,
        description='ID assigned by the server receiving the report.  Not populated when submitting a report.',
    )
    exchange: ExchangeRecord = Field(
        ...,
        description='The request (by this PSU) and response associated with the error.',
    )


class Polygon(BaseModel):
    vertices: List[LatLngPoint] = Field(..., min_items=3)


class Volume3D(BaseModel):
    outline_circle: Optional[Circle] = Field(
        None, description='A circular geographic shape on the surface of the earth.'
    )
    outline_polygon: Optional[Polygon] = Field(
        None, description='A polygonal geographic shape on the surface of the earth.'
    )
    altitude_lower: Altitude = Field(
        ...,
        description='Minimum bounding altitude of this volume. Must be less than altitude_upper, if specified.',
    )
    altitude_upper: Altitude = Field(
        ...,
        description='Maximum bounding altitude of this volume. Must be greater than altitude_lower, if specified.',
    )


class Volume4D(BaseModel):
    volume: Volume3D
    time_start: Time = Field(
        ..., description='Beginning time of this volume. Must be before time_end.'
    )
    time_end: Time = Field(
        ..., description='End time of this volume. Must be after time_start.'
    )


class SubscriptionState(BaseModel):
    subscription_id: SubscriptionID
    notification_index: SubscriptionNotificationIndex


class OperationalIntentReference(BaseModel):
    id: EntityID
    manager: str = Field(
        ...,
        description="Created by the DSS based on creating client's ID (via access token).  Used internal\nto the DSS for restricting mutation and deletion operations to manager.  Used by PSUs\nto reject operational intent update notifications originating from a PSU that does not manage\nthe operational intent.",
        example='psu1',
    )
    uss_availability: UssAvailabilityState
    version: int = Field(
        ...,
        description='Numeric version of this operational intent which increments upon each change in the operational intent,\nregardless of whether any field of the operational intent reference changes.  A PSU with the\ndetails of this operational intent when it was at a particular version does not need to retrieve\nthe details again until the version changes.',
        example=1,
    )
    state: OperationalIntentState
    ovn: Optional[EntityOVN] = Field(
        None,
        description='Opaque version number of this operational intent.  Populated only when the OperationalIntentReference\nis managed by the PSU retrieving or providing it.  Not populated when the\nOperationalIntentReference is not managed by the PSU retrieving or providing it (instead, the\nPSU must obtain the OVN from the details retrieved from the managing PSU).',
    )
    time_start: Time = Field(
        ...,
        description='Beginning time of operational intent. The estimated time at which the aircraft will commence movement associated with departure\u200b (ETD).',
    )
    time_end: Time = Field(
        ...,
        description='End time of operational intent. The estimated time at which the aircraft will arrive at the destination vertiport (ETA).',
    )
    uss_base_url: OperationalIntentUssBaseURL
    subscription_id: SubscriptionID = Field(
        ...,
        description='The ID of the subscription that is ensuring the operational intent manager receives relevant\nairspace updates.',
    )


class ConstraintReference(BaseModel):
    id: EntityID
    manager: str = Field(
        ...,
        description="Created by the DSS based on creating client's ID (via access token).  Used internal\nto the DSS for restricting mutation and deletion operations to manager.  Used by PSUs\nto reject constraint update notifications originating from a PSU that does not manage\nthe constraint.",
        example='psu1',
    )
    uss_availability: UssAvailabilityState
    version: int = Field(
        ...,
        description='Numeric version of this constraint which increments upon each change in the constraint,\nregardless of whether any field of the constraint reference changes.  A PSU with the\ndetails of this constraint when it was at a particular version does not need to retrieve\nthe details again until the version changes.',
        example=1,
    )
    ovn: Optional[EntityOVN] = Field(
        None,
        description='Opaque version number of this constraint.  Populated only when the ConstraintReference\nis managed by the PSU retrieving or providing it.  Not populated when the\nConstraintReference is not managed by the PSU retrieving or providing it (instead, the\nPSU must obtain the OVN from the details retrieved from the managing PSU).',
    )
    time_start: Time
    time_end: Time
    uss_base_url: ConstraintUssBaseURL


class ConstraintDetails(BaseModel):
    volumes: List[Volume4D] = Field(
        ...,
        description='Volumes that wholly contain the constraint while being as small as practical.\nThe end time may not be in the past.',
        min_items=1,
    )
    type: Optional[str] = Field(
        None,
        description='Type of airspace feature this constraint represents.',
        example='com.example.non_utm_aircraft_operations',
    )


class Constraint(BaseModel):
    reference: ConstraintReference
    details: ConstraintDetails


class PutConstraintDetailsParameters(BaseModel):
    constraint_id: EntityID = Field(
        ..., description='ID of constraint that has changed.'
    )
    constraint: Optional[Constraint] = Field(
        None,
        description='Full information about the constraint that has changed.  If this field is omitted,\nthe constraint was deleted.  The `ovn` field in the nested `reference` must be\npopulated.',
    )
    subscriptions: List[SubscriptionState] = Field(
        ..., description='Subscription(s) prompting this notification.', min_items=1
    )


class GetConstraintDetailsResponse(BaseModel):
    constraint: Constraint


class VehicleTelemetry(BaseModel):
    time_measured: Time
    position: Position
    velocity: Velocity


class TrajectoryPoint4D(BaseModel):
    point_designator: Optional[str] = Field(
        None,
        description='The name of the designated point. This is required for all named airspace structure point from ASDS, including vertipads.',
        example='ee123',
    )
    lat_lng_point: LatLngPoint = Field(
        ...,
        description='Latitude and Longitude of the point. If this is for a named airspace structure point from ASDS, it should be the same value as from ASDS.',
    )
    altitude: Altitude = Field(
        ...,
        description='Altitude of the point. If this is for a named airspace structure point from ASDS, it should be the same value as from ASDS.',
    )
    time: Time = Field(
        ...,
        description='Estimated time when the vehicle will be at the location of the TrajectoryPoint',
    )
    speed: Velocity = Field(
        ...,
        description='Speed of the vehicle at this TrajectoryPoint.\nFIXM allows for two speed entries:  predictedAirspeed and predictedGroundspeed',
    )
    trajectory_property_array: List[TrajectoryProperty] = Field(
        ...,
        description='Describes any applicable properties of the trajectory point.\nMay include multiple properties per point. FIXM allows up to 2000 properties per\ntrajectory point. For X4 we are allowing up to 4.\nThe first point of initial plan must include at a minimum: AIRPORT_REFERENCE_LOCATION, WHEELS_OFF\nThe last point must include at a minimum: AIRPORT_REFERENCE_LOCATION, WHEELS_ON\nA named airspace structure point from ASDS must include at a minimum: WAYPOINT\nIf the airspace structure point has a SchedulingType, it must be included as follows:\n  SchedulingType enum   |   Property enum\n  Entry                 |   ENTRY_CORRIDOR\n  Exit                  |   EXIT_CORRIDOR\n  Crossing              |   CROSSING_TRACK\n  Merge                 |   MERGE_TRACK',
        max_items=4,
        min_items=1,
    )


class UssAvailabilityStatus(BaseModel):
    uss: str = Field(
        ...,
        description='Client ID (matching their `sub` in access tokens) of the USS to which this availability applies.',
    )
    availability: UssAvailabilityState


class OperationalIntentDetails(BaseModel):
    aircraft_registration: Optional[
        constr(regex=r'[A-Z0-9]{1,7}', min_length=1, max_length=7)
    ] = Field(
        None,
        description='A unique, alphanumeric string that identifies a civil aircraft and consists of the Aircraft\nNationality or Common Mark and an additional alphanumeric string, the registration mark,\nassigned by the state of registry or common mark registering authority. [FIXM]\n',
    )
    operator_name: Optional[constr(regex=r'[A-Z]{3}')] = Field(
        None,
        description='The identifier of the UAM Operator. Required if different than the PSU. For X4 this can be any code that meets the required pattern, and does not need to be an ICAO Airline Code.\u200b',
        example='AAL',
    )
    trajectory: List[TrajectoryPoint4D] = Field(
        ...,
        description='The list of TrajectoryPoints for this operation.  This list must contain\nall significant TrajectoryPoints per the CBRs. For additional insight on \npoints to be included, see the enumeration of property types in the \nTrajectoryPoint4D model.',
        max_items=1000,
        min_items=2,
    )


class OperationalIntent(BaseModel):
    reference: OperationalIntentReference
    details: OperationalIntentDetails


class PutOperationalIntentDetailsParameters(BaseModel):
    operational_intent_id: EntityID = Field(
        ..., description='ID of operational intent that has changed.'
    )
    operational_intent: Optional[OperationalIntent] = Field(
        None,
        description='Full information about the operational intent that has changed.  If this field is omitted,\nthe operational intent was deleted.  The `ovn` field in the nested `reference` must be\npopulated.',
    )
    subscriptions: List[SubscriptionState] = Field(
        ..., description='Subscription(s) prompting this notification.', min_items=1
    )


class GetOperationalIntentDetailsResponse(BaseModel):
    operational_intent: OperationalIntent


class GetOperationalIntentTelemetryResponse(BaseModel):
    operational_intent_id: EntityID = Field(
        ...,
        description='ID of the operational intent which the vehicle reporting telemetry is flying.',
    )
    telemetry: VehicleTelemetry
    next_telemetry_opportunity: Optional[Time] = Field(
        None,
        description='The next telemetry similar to this telemetry is not expected to be\navailable until at or after this time, so the polling PSU should\ngenerally not poll the endpoint providing this response data again\nuntil at or after that time.  If this field is omitted, then there\nis no current expectation of new telemetry becoming available.',
    )
